<!--TO READ THIS HELP FILE, RIGHT-CLICK ON THE FILE NAME IN THE
    SOLUTION EXPLORER PANE AND SELECT "VIEW IN BROWSER"-->

<html><head><title>SOAPTransport Sample: Communicates SOAP Messages Over Sockets, MSMQ, the File System, and HTTP Listener</title></head><body><h1>SOAPTransport Sample: Communicates SOAP Messages Over Sockets, MSMQ, the File System, and HTTP Listener</h1><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()"></div><p /><p>Demonstrates the creation of SOAP servers and clients that communicate using different transports: sockets, Microsoft Message Queue, the file system, and a custom HTTP listener.</p><p>The SOAPTransport sample consists of eight projects: a SOAP server and a client for each of the four supported transports.</p><p>The sample shows how to separate the SOAP support offered by ATL Server from the ISAPI framework, allowing use of ATL Server to build SOAP servers and clients over virtually any communication channel.</p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Security Note </th></tr><tr><td><p>This sample code is provided to illustrate a concept and should not be used in applications or Web sites, as it may not illustrate the safest coding practices.</p></td></tr></table></div><h1 class="heading">Requirements</h1><div id="requirementsSection" class="section"><ul><li><p>MSMQ</p></li></ul></div><h1 class="heading">Building and Running the Sample</h1><div id="sectionSection0" class="seeAlsoNoToggleSection"><h4 class="subHeading">To build and run this sample</h4><div class="subSection"><ol><li><p>Open the solution file, SoapTransport.sln, in the Visual Studio development environment. </p></li><li><p>Build the solution. </p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Note </th></tr><tr><td><p>This will build all the client and server applications.</p></td></tr></table></div></li><li><p>Run FloppyTransport: </p><ol><li><p>Start the FloppyClient application. It will ask for the name of the file to save the request to. Enter a file name.</p></li><li><p>Start the FloppyServer application. It will ask for the file containing the request. Enter the file where the request was saved.</p></li><li><p>The server application will ask for a file to save the response to. Enter a file name.</p></li><li><p>Return to the FloppyClient running instance and press any key. It will ask for the file containing the response. Enter the file where the server saved the SOAP response. </p><p>The result of the SOAP invocation is displayed. </p></li></ol></li><li><p>Run TCPIPTransport: </p><ol><li><p>Start the TCPServer application. It will launch the TCP/IP listener.</p></li><li><p>Start the TCPClient application. It will send the request and then display the result of the invocation.</p></li></ol></li><li><p>Run MSMQTransport (you will need the Message Queuing Services installed on your computer): </p><ol><li><p>Start the MQServer application. It will create a message queue and wait for a message containing a SOAP request to be posted.</p></li><li><p>Start the MQClient application. It will post the request and then display the result of the invocation.</p></li></ol></li><li><p>Run HTTPListenerTransport: </p><ol><li><p>Start the HTTPListenerServer application. It will wait for a message containing a SOAP request to be posted.</p></li><li><p>Start the HTTPListenerCSharpClient application. It will send the request and then display the result of the invocation.</p></li></ol></li></ol></div></div><h1 class="heading">How the Sample Works</h1><div id="sectionSection1" class="seeAlsoNoToggleSection"><p>The following discussion covers the server, client, and transports.</p><sections ><h4 class="subHeading" xmlns="">Server Side</h4><div class="subSection" xmlns=""><p>The ATL Server Web Service application wizard will generate the code for an XML Web service exposed through HTTP. The XML Web service is implemented as a class with the following declaration:</p><div class="code"><span codeLanguage="other"><table width="100%" cellspacing="0" cellpadding="0"><tr><td colspan="2"><pre>[
request_handler(name="Default", sdl="GenSimpleSoapAppServiceWSDL"),
soap_handler(
      name="SimpleSoapAppService", 
      namespace="urn:SimpleSoapAppService",
      protocol="soap"
   )
]
class CSimpleSoapAppService :
   public ISimpleSoapAppService</pre></td></tr></table></span></div><p>In this code sequence, the attributes before the class declaration do most of the work. The <code>soap_handler</code> attribute will make the class a <code>CSoapHandler&lt;CSimpleSoapAppService&gt;</code> derivative (that is, an XML Web service) able to handle SOAP messages and map them to internal method calls, and also to wrap the result of internal method invocations to SOAP responses. The <code>request_handler</code> attribute will make it able to handle HTTP requests.</p><p>If the transport layer is not going to be HTTP, the <code>request_handler</code> attribute is no longer needed, so it can be commented out.</p><p>The <code>CSoapHandler&lt;&gt;</code> class in atlsoap.h is designed to handle SOAP requests through HTTP. The entry point for handling an HTTP SOAP request is:</p><div class="code"><span codeLanguage="other"><table width="100%" cellspacing="0" cellpadding="0"><tr><td colspan="2"><pre>HTTP_CODE HandleRequest(AtlServerRequest *, IServiceProvider *)</pre></td></tr></table></span></div><p>The request body and the SOAP-related HTTP header ("SOAPAction") are retrieved from the ISAPI extension through the <code>pServerRequest</code> (an ECB wrapper) member of the <code>AtlServerRequest*</code> parameter. </p><p>The <code>pServerRequest</code> object provides methods for reading the request body, reading the SOAPAction HTTP header, and writing the SOAP response back to the client. As this sample intends to replace the HTTP transport, it needs to launch the SOAP request processing and to provide it with a way of performing the same operations. </p><p>This is solved by creating a <code>CSoapHandler</code> derivative, <code>CSoapTransportHandler</code>, that implements the following entry point (in file SoapTransportSrv.h of the sample):</p><div class="code"><span codeLanguage="other"><table width="100%" cellspacing="0" cellpadding="0"><tr><td colspan="2"><pre>HTTP_CODE InvokeSoapMethod(stSoapTransportDescription   *pTransInfo) </pre></td></tr></table></span></div><p>The <code>stSoapTransportDescription</code> is defined as:</p><div class="code"><span codeLanguage="other"><table width="100%" cellspacing="0" cellpadding="0"><tr><td colspan="2"><pre>struct  stSoapTransportDescription
{
// the stream to write the SOAP response to
   IWriteStream   *pWriteStream;   
// the stream to read the SOAP request from
   IStream      *pReadStream;
// the SOAP Action   
CStringA         strSOAPAction;    
// the service provider
   IServiceProvider   *pServiceProvider; 
};</pre></td></tr></table></span></div><p>Perhaps the only member that needs explanation is <code>pServiceProvider</code>. It allows the SOAP servers to share services exactly as those in an ISAPI DLL. It can be NULL in an implementation, as long as the SOAP servers will not attempt to use it. One of the services commonly exposed through the service provider is the MSXML Reader.</p><p>Now, the SOAP server class generated by the wizard has to be modified to use the new <code>CSoapTransportHandler</code> functionality. The new code would look like this:</p><div class="code"><span codeLanguage="other"><table width="100%" cellspacing="0" cellpadding="0"><tr><td colspan="2"><pre>[
      // request_handler(name="Default", sdl= "GenSimpleSoapAppWSDL"),
   soap_handler(
      name="SimpleSoapAppService", 
      namespace="urn:SimpleSoapAppService",
      protocol="soap"
   )
]
class CSimpleSoapAppService :
   public CSoapTransportHandler&lt;CSimpleSoapAppService&gt;,
   public ISimpleSoapAppService</pre></td></tr></table></span></div><p>No other modifications need to be done in the server code.</p><p>At this point, the SOAP server can be instantiated and the SOAP methods can be invoked through <code>CSoapTransportHandler::InvokeSoapMethod</code>. Using custom read and write streams, there is no longer a dependency on ATL Server HTTP support.</p><p>The instantiation of the server or servers is handled by another class, <code>CSoapDispatcher</code>, implemented in the soapDispatch.h file of the sample. </p><p>At this point, a server application only has to:  </p><ul><li><p>Get the SOAP request and the SOAP Action header through any transport channel.</p></li><li><p>Wrap the request in an <code>IStream</code> interface.</p></li><li><p>Provide a stream to store the response.</p></li><li><p>Invoke <code>CSoapDispatcher::DispatchCall</code>.</p></li><li><p>Send the content of the write stream (the SOAP response) over any transport channel to the client.</p></li></ul></div><h4 class="subHeading" xmlns="">Client Side</h4><div class="subSection" xmlns=""><p>The template-based code generated by the sproxy.exe tool for an ATL Server SOAP client makes for easy overriding of the transport on the client side. The SOAP proxy class generated by sproxy.exe has the following prototype:</p><div class="code"><span codeLanguage="other"><table width="100%" cellspacing="0" cellpadding="0"><tr><td colspan="2"><pre>template &lt;typename TClient = CSoapSocketClientT&lt;&gt; &gt;
class CSimpleSoapAppServiceT </pre></td></tr></table></span></div><p>The methods that have to be implemented by the <code>TClient</code> template parameter are well documented in the <MSHelp:link keywords="63147C24-A604-432E-AC9C-CFAEC33E618C" tabindex="0" >ATL Server Reference</MSHelp:link>. The method that is really of importance here is <code>SendRequest</code>. That method is supposed to send the request from a stream to the SOAP server and to fill a different stream with the server response. </p><p>With a custom class that contains all of the methods required to be a <code>TClient</code>, the actual channel used to send the request to the SOAP server only affects the implementation of the <code>SendRequest</code> method. </p></div><h4 class="subHeading" xmlns="">Transport Channels</h4><div class="subSection" xmlns=""><p>The sample implements the following transport channels:  </p><ul><li><p>TCP/IP communication</p></li><li><p>MSMQ communication</p></li><li><p>Communication through files</p></li></ul><p>Each transport channel implementation contains a client application and a server application. The server uses the SOAP server included in the "Include" folder (which is built as described above). The code in the server application only takes care of the transport. The client application only implements the transport-specific class to act as a TClient parameter for the Sproxy.exe-generated class.</p><p>A limitation of the sample is that the WSDL used in generating the proxy has to be generated outside of the sample. The WSDL used in the applications specified above is saved as simpleSoapSrv.wsdl in the "Include" folder. The solution for this would be to create the SOAP server through the wizard, complete the interface and then save the WSDL through the default HTTP way provided by ATL Server.</p></div><h4 class="subHeading" xmlns="">An Extension: HTTPListenerTransport</h4><div class="subSection" xmlns=""><p>This folder contains an enhanced version of the TCPIPTransport server. This server listens on a specified TCPIP port, but it accepts HTTP requests. It provides a way of responding to .disco requests, to generate the WSDL for the implemented SOAP servers and also to accept SOAP invocations. This server can provide a very lightweight, complete, SOAP implementation without requiring an HTTP server to be installed on the computer.</p><p>To create a client for this lightweight server, use the Add Web Reference wizard from the Visual Studio IDE and point the wizard to the following URL:</p><p>http://&lt;your_machine&gt;:&lt;ListenPort&gt;/disco</p><p>The client provided for this server (<b>HttpListenerCSharpClient</b>) is generated this way.</p></div><h4 class="subHeading" xmlns="">Demonstrates</h4><div class="subSection" xmlns=""><p><MSHelp:link keywords="9E197B8D-D8E2-4D43-9145-5027878F52AC" tabindex="0" >CSoapHandler</MSHelp:link> | <MSHelp:link keywords="A2584490-1318-47DF-AFFA-21E7F0CE33E7" tabindex="0" >CSoapHandler::SoapFault</MSHelp:link> | <MSHelp:link keywords="82836DB5-3A7D-48E4-A955-9223324F9A2D" tabindex="0" >CSoapRootHandler::GenerateResponse</MSHelp:link> | <MSHelp:link keywords="A72EFD50-8E81-4187-8698-27816395B620" tabindex="0" >CSoapHandler::SetHttpError</MSHelp:link> | <MSHelp:link keywords="13087A34-EEB8-4E52-8CBA-87080B86DE2E" tabindex="0" >CSoapRootHandler::InitializeSOAP</MSHelp:link> | <MSHelp:link keywords="0EB2B72C-0BF5-4B72-BB65-3F07892211DF" tabindex="0" >CSoapRootHandler::BeginParse</MSHelp:link> | <MSHelp:link keywords="31B53211-9093-4444-9028-6AE0EAD35A42" tabindex="0" >CSoapRootHandler::CallFunctionInternal</MSHelp:link> | <MSHelp:link keywords="C4810EB0-5F59-4D00-B14F-8CBA8A3763C7" tabindex="0" >CSoapRootHandler::UninitializeSOAP</MSHelp:link> | <MSHelp:link keywords="57D7F506-B69C-4A4B-A03A-5CB8CA77FAD2" tabindex="0" >soap_handler</MSHelp:link> | <MSHelp:link keywords="93C8A7F0-C0D5-42A0-BB6F-02C25054E272" tabindex="0" >request_handler</MSHelp:link> | <MSHelp:link keywords="EC2E276C-6E6F-409D-9EEB-E82D5EEBF202" tabindex="0" >CAtlIsapiBuffer</MSHelp:link></p></div></sections></div></div><div id="footer"><div class="footerLine"></div>
          © Microsoft Corporation. All rights reserved.  Send <a href="mailto:DevDocs@microsoft.com?subject=Documentation Feedback :SOAPTransport Sample: Communicates SOAP Messages Over Sockets, MSMQ, the File System, and HTTP Listener">comments</a> about this topic to Microsoft.
      </div></div></body></html>
